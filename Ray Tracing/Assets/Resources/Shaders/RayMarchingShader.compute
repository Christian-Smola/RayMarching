//Based on the following article by Inigo Quilez
//https://iquilezles.org/articles/distfunctions/
#pragma kernel CSMain

RWTexture2D<float4> Result;
float4 _DirectionalLight;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
int _Operation;

Texture2D<float4> _PlanetTexture;
SamplerState sampler_PlanetTexture;

Texture2D<float4> _PlanetNormalTexture;
SamplerState sampler_PlanetNormalTexture;

Texture2D<float4> _PlanetaryRingTexture;
SamplerState sampler_PlanetaryRingTexture;

Texture2D<float4> _PlanetaryRingNormalTexture;
SamplerState sampler_PlanetaryRingNormalTexture;

Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

static const float PI = 3.14159265f;
static const float MaxDist = 80;
static const float Epsilon = 0.001f;

struct Ray
{
    float3 origin;
    float3 direction;
};

struct Mesh
{
    float3 position;
    float3 size;
    int meshID;
    int shape;
};

StructuredBuffer<Mesh> Meshes;
int MeshCount;

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

float mix(float x, float y, float a)
{
    return x * (1 - a) + y * a;
}

float PlaneSDF(float3 pos, float3 normal, float DistFromOrigin)
{
    return dot(pos, normal) + DistFromOrigin;
}

float SphereSDF(float3 CameraPos, float3 Center, float Radius)
{
    return length(CameraPos - Center) - Radius;
}

float CubeSDF(float3 CameraPos, float3 Center, float3 Size)
{
    float3 Offset = abs(CameraPos - Center) - Size;
    float UnsignedDistance = length(max(Offset, 0));
    float DistanceInsideBox = max(max(min(Offset.x, 0), min(Offset.y, 0)), min(Offset.z, 0));
    return UnsignedDistance + DistanceInsideBox;
}

float TorusSDF(float3 pos, float2 t)
{
    float2 q = float2(length(pos.xz) - t.x, pos.y);
    return length(q) - t.y;
}

float4 opElongate(in float3 p, in float3 h)
{
    float3 q = abs(p) - h;
    return float4(max(q, 0), min(max(q.x, max(q.y, q.z)), 0));
}

float GetMeshSDF(Mesh mesh, float3 pos)
{
    if (mesh.shape == 0)
        return SphereSDF(pos, mesh.position, mesh.size.x);
    if (mesh.shape == 1)
        return CubeSDF(pos, mesh.position, mesh.size);
    if (mesh.shape == 2)
        return PlaneSDF(pos, float3(0, 1, 0), 1.5f);
    if (mesh.shape == 3)
    {
        float3 q = pos - mesh.position;
        float4 w = opElongate(q, float3(0, -mesh.size.y + 0.2f, 0));
        return w.w + TorusSDF(w.xyz, mesh.size.xy);
    }

    return MaxDist;
}

float4 Combine(float distA, float distB, float3 colorA, float3 colorB)
{
    float dist = distA;
    float3 color = colorA;
    float blendValue = 6.5f;

    if (_Operation == 0)
    {
        //Default
        if (distB < distA)
        {
            dist = distB;
            color = colorB;
        }
    }
    else if (_Operation == 1)
    {
        //Blend
        float h = clamp(0.5f + 0.5f * (distB - distA) / blendValue, 0.0f, 1.0f);
        dist = lerp(distB, distA, h) - blendValue * h * (1 - h);
        color = lerp(colorB, colorA, h);
    }
    else if (_Operation == 2)
    {
        //Union
        float h = clamp(0.5f + 0.5f * (distB - distA) / blendValue, 0.0f, 1.0f);
        dist = mix(distB, distA, h) - blendValue * h * (1 - h);
        color = lerp(colorB, colorA, h);
    }
    else if (_Operation == 3)
    {
        //Subtraction
        float h = clamp(0.5f - 0.5f * (distB + distA) / blendValue, 0.0f, 1.0f);
        dist = mix(distB, -distA, h) + blendValue * h * (1 - h);
        color = lerp(colorB, colorA, h);
    }

    return float4(color, dist);
}

float LimitedDomainRepetition(in float3 pos, in float3 spacing, in Mesh mesh)
{
    float3 q = pos - spacing * clamp(round(pos / spacing), -1, 1);
    return GetMeshSDF(mesh, q);
}

float DistToScene(float3 pos)
{
    float GlobalDist = MaxDist;

    for (int x = 0; x < MeshCount; x++)
    {
        Mesh mesh = Meshes[x];
        float MeshDist = GetMeshSDF(mesh, pos);

        if (MeshDist < GlobalDist)
            GlobalDist = MeshDist;
    }

    return GlobalDist;
}

float3 CalculateNormals(float3 pos)
{
    float3 V1 = float3(
        DistToScene(pos + float3(Epsilon, 0, 0)),
        DistToScene(pos + float3(0, Epsilon, 0)),
        DistToScene(pos + float3(0, 0, Epsilon)));

    float3 V2 = float3(
        DistToScene(pos - float3(Epsilon, 0, 0)),
        DistToScene(pos - float3(0, Epsilon, 0)),
        DistToScene(pos - float3(0, 0, Epsilon)));

    return normalize(V1 - V2);
}

float3 CalculateTextures(float3 pos, float3 dir)
{
    float GlobalDist = MaxDist;
    float3 GlobalColor = 0;

    for (int x = 0; x < MeshCount; x++)
    {
        Mesh mesh = Meshes[x];
        float MeshDist = GetMeshSDF(mesh, pos);

        if (MeshDist < GlobalDist)
        {
            float3 HitPoint = pos + dir * MeshDist;
            float3 normals = CalculateNormals(HitPoint - dir * Epsilon);

            if (mesh.meshID == 1)
            {
                float3 XY = _PlanetTexture.SampleLevel(sampler_PlanetTexture, HitPoint.xy * 0.5f + 0.5f, 0).xyz;
                float3 XZ = _PlanetTexture.SampleLevel(sampler_PlanetTexture, HitPoint.xz * 0.5f + 0.5f, 0).xyz;
                float3 YZ = _PlanetTexture.SampleLevel(sampler_PlanetTexture, HitPoint.yz * 0.5f + 0.5f, 0).xyz;

                normals = abs(normals);

                float3 col = (XY * normals.z) + (XZ * normals.y) + (YZ * normals.x);

                XY = _PlanetNormalTexture.SampleLevel(sampler_PlanetNormalTexture, HitPoint.xy * 0.5f + 0.5f, 0).xyz;
                XZ = _PlanetNormalTexture.SampleLevel(sampler_PlanetNormalTexture, HitPoint.xz * 0.5f + 0.5f, 0).xyz;
                YZ = _PlanetNormalTexture.SampleLevel(sampler_PlanetNormalTexture, HitPoint.yz * 0.5f + 0.5f, 0).xyz;

                normals = (XY * normals.z) + (XZ * normals.y) + (YZ * normals.x);
                normals = saturate(dot(normals, _DirectionalLight.xyz));

                GlobalColor = col * normals;
            }
            else if (mesh.meshID == 2)
            {
                float3 XY = _PlanetaryRingTexture.SampleLevel(sampler_PlanetaryRingTexture, HitPoint.xy * 0.5f + 0.5f, 0).xyz;
                float3 XZ = _PlanetaryRingTexture.SampleLevel(sampler_PlanetaryRingTexture, HitPoint.xz * 0.5f + 0.5f, 0).xyz;
                float3 YZ = _PlanetaryRingTexture.SampleLevel(sampler_PlanetaryRingTexture, HitPoint.yz * 0.5f + 0.5f, 0).xyz;

                normals = abs(normals);

                float3 col = (XY * normals.z) + (XZ * normals.y) + (YZ * normals.x);

                XY = _PlanetaryRingNormalTexture.SampleLevel(sampler_PlanetaryRingNormalTexture, HitPoint.xy * 0.5f + 0.5f, 0).xyz;
                XZ = _PlanetaryRingNormalTexture.SampleLevel(sampler_PlanetaryRingNormalTexture, HitPoint.xz * 0.5f + 0.5f, 0).xyz;
                YZ = _PlanetaryRingNormalTexture.SampleLevel(sampler_PlanetaryRingNormalTexture, HitPoint.yz * 0.5f + 0.5f, 0).xyz;

                normals = (XY * normals.z) + (XZ * normals.y) + (YZ * normals.x);
                normals = saturate(dot(normals, _DirectionalLight.xyz));

                GlobalColor = col * normals;
            }

            GlobalDist = MeshDist;
        }
        else {
            GlobalColor = GlobalColor;
        }
    }

    return GlobalColor;
}

float CalculateHardShadows(Ray ray, float DistToShadePoint)
{
    float rayDist = 0;
    int marchSteps = 0;
    float shadowIntensity = 0.2f;
    float brightness = 1;

    while (rayDist < DistToShadePoint)
    {
        marchSteps++;
        float dist = DistToScene(ray.origin);

        if (dist <= Epsilon)
            return shadowIntensity;

        brightness = min(brightness, dist * 200);

        ray.origin += ray.direction * dist;
        rayDist += dist;
    }

    return shadowIntensity + (1 - shadowIntensity) * brightness;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);

    float2 uv = id.xy / float2(width, height) * 2 - 1;
    float RayDist = 0;

    Ray ray = CreateCameraRay(uv);
    int MarchSteps = 0;

    while (RayDist < MaxDist)
    {
        MarchSteps++;

        float dist = DistToScene(ray.origin);

        if (dist <= Epsilon)
        {
            //Lighting
            float3 HitPoint = ray.origin + ray.direction * dist;
            float3 normals = CalculateNormals(HitPoint - ray.direction * Epsilon);
            float3 Lighting = saturate(dot(normals, _DirectionalLight.xyz) * -1) * _DirectionalLight.w;

            //Shadows
            float3 offsetPos = HitPoint + normals * 0.05f;
            float3 dirToLight = -_DirectionalLight;

            ray.origin = offsetPos;
            ray.direction = dirToLight;

            float distToLight = MaxDist;
            float Shadows = CalculateHardShadows(ray, distToLight);

            //Textures
            float3 Textures = CalculateTextures(ray.origin, ray.direction);

            Result[id.xy] = float4(Textures * Lighting * Shadows, 1);

            break;
        }
        else
        {
            float theta = acos(ray.direction.y) / -PI;
            float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
            Result[id.xy] = float4(_SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz, 1);
        }

        ray.origin += ray.direction * dist;
        RayDist += dist;
    }
}
