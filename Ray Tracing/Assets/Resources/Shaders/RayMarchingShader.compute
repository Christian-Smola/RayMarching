//Based on the following article by Inigo Quilez
//https://iquilezles.org/articles/distfunctions/
#pragma kernel CSMain

RWTexture2D<float4> Result;
float4 _DirectionalLight;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
int _Operation;

Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

static const float PI = 3.14159265f;
static const float MaxDist = 80;
static const float Epsilon = 0.001f;

struct Ray
{
    float3 origin;
    float3 direction;
};

struct Mesh
{
    float3 position;
    float3 size;
    float3 color;
    int shape;
};

StructuredBuffer<Mesh> Meshes;
int MeshCount;

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

float mix(float x, float y, float a)
{
    return x * (1 - a) + y * a;
}

float PlaneSDF(float3 pos, float3 normal, float DistFromOrigin)
{
    return dot(pos, normal) + DistFromOrigin;
}

float SphereSDF(float3 CameraPos, float3 Center, float Radius)
{
    return length(CameraPos - Center) - Radius;
}

float CubeSDF(float3 CameraPos, float3 Center, float3 Size)
{
    float3 Offset = abs(CameraPos - Center) - Size;
    float UnsignedDistance = length(max(Offset, 0));
    float DistanceInsideBox = max(max(min(Offset.x, 0), min(Offset.y, 0)), min(Offset.z, 0));
    return UnsignedDistance + DistanceInsideBox;
}

float GetMeshSDF(Mesh mesh, float3 pos)
{
    if (mesh.shape == 0)
        return SphereSDF(pos, mesh.position, mesh.size.x);
    if (mesh.shape == 1)
        return CubeSDF(pos, mesh.position, mesh.size);
    if (mesh.shape == 2)
        return PlaneSDF(pos, float3(0, 1, 0), 1.5f);

    return MaxDist;
}

float4 Combine(float distA, float distB, float3 colorA, float3 colorB)
{
    float dist = distA;
    float3 color = colorA;
    float blendValue = 0.3f;

    if (_Operation == 0)
    {
        //Default
        if (distB < distA)
        {
            dist = distB;
            color = colorB;
        }
    }
    else if (_Operation == 1)
    {
        //Blend
        float h = clamp(0.5f + 0.5f * (distB - distA) / blendValue, 0.0f, 1.0f);
        dist = lerp(distB, distA, h) - blendValue * h * (1 - h);
        color = lerp(colorB, colorA, h);
    }
    else if (_Operation == 2)
    {
        //Union
        float h = clamp(0.5f + 0.5f * (distB - distA) / blendValue, 0.0f, 1.0f);
        dist = mix(distB, distA, h) - blendValue * h * (1 - h);
        color = lerp(colorB, colorA, h);
    }
    else if (_Operation == 3)
    {
        //Subtraction
        float h = clamp(0.5f - 0.5f * (distB + distA) / blendValue, 0.0f, 1.0f);
        dist = mix(distB, -distA, h) + blendValue * h * (1 - h);
        color = lerp(colorB, colorA, h);
    }

    return float4(color, dist);
}

float LimitedDomainRepetition(in float3 pos, in float3 spacing, in Mesh mesh)
{
    float3 q = pos - spacing * clamp(round(pos / spacing), -1, 1);
    return GetMeshSDF(mesh, q);
}

float4 SampleScene(float3 pos)
{
    float GlobalDist = MaxDist;
    float3 GlobalColor = 0;

    for (int x = 0; x < MeshCount; x++)
    {
        Mesh mesh = Meshes[x];
        float MeshDist = LimitedDomainRepetition(pos, float3(5, 5, 0), mesh);
        float3 MeshColor = mesh.color;

        float4 GlobalCombined = Combine(GlobalDist, MeshDist, GlobalColor, MeshColor);
        GlobalColor = GlobalCombined.xyz;
        GlobalDist = GlobalCombined.w;
    }

    return float4(GlobalColor, GlobalDist);
}

float3 CalculateNormals(float3 pos)
{
    float3 V1 = float3(
        SampleScene(pos + float3(Epsilon, 0, 0)).w,
        SampleScene(pos + float3(0, Epsilon, 0)).w,
        SampleScene(pos + float3(0, 0, Epsilon)).w);

    float3 V2 = float3(
        SampleScene(pos - float3(Epsilon, 0, 0)).w,
        SampleScene(pos - float3(0, Epsilon, 0)).w,
        SampleScene(pos - float3(0, 0, Epsilon)).w);

    return normalize(V1 - V2);
}

float CalculateHardShadows(Ray ray, float DistToShadePoint)
{
    float rayDist = 0;
    int marchSteps = 0;
    float shadowIntensity = 0.2f;
    float brightness = 1;

    while (rayDist < DistToShadePoint)
    {
        marchSteps++;
        float4 sampleResult = SampleScene(ray.origin);
        float dist = sampleResult.w;

        if (dist <= Epsilon)
            return shadowIntensity;

        brightness = min(brightness, dist * 200);

        ray.origin += ray.direction * dist;
        rayDist += dist;
    }

    return shadowIntensity + (1 - shadowIntensity) * brightness;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);

    float2 uv = id.xy / float2(width, height) * 2 - 1;
    float RayDist = 0;

    Ray ray = CreateCameraRay(uv);
    int MarchSteps = 0;

    while (RayDist < MaxDist)
    {
        MarchSteps++;

        float4 SampleResult = SampleScene(ray.origin);
        float dist = SampleResult.w;

        if (dist <= Epsilon)
        {
            float3 col = SampleResult.xyz;

            //Lighting
            float3 HitPoint = ray.origin + ray.direction * dist;
            float3 normals = CalculateNormals(HitPoint - ray.direction * Epsilon);
            float3 Lighting = saturate(dot(normals, _DirectionalLight.xyz) * -1) * _DirectionalLight.w;

            //Shadows
            float3 offsetPos = HitPoint + normals * 0.05f;
            float3 dirToLight = -_DirectionalLight;

            ray.origin = offsetPos;
            ray.direction = dirToLight;

            float distToLight = MaxDist;
            float Shadows = CalculateHardShadows(ray, distToLight);

            Result[id.xy] = float4(col * Lighting * Shadows, 1);

            break;
        }
        else
        {
            float theta = acos(ray.direction.y) / -PI;
            float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
            Result[id.xy] = float4(_SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz, 1);
        }

        ray.origin += ray.direction * dist;
        RayDist += dist;
    }
}
